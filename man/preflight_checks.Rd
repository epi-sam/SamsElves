% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preflight_checks.R
\name{preflight_checks}
\alias{preflight_checks}
\title{Compare reference vectors or data.frames using Tidyverse grammar}
\usage{
preflight_checks(
  X,
  Y,
  method = c("all_equal"),
  colsX = c("location_id"),
  colsY = NULL,
  filter_statement = NULL,
  STOP = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{X}{Left-hand input vector or data.frame (gold standard to compare against)}

\item{Y}{Right-hand input vector or data.frame (compared AGAINST your gold standard, by 'method')}

\item{method}{method of comparison to be made:
all_equal = compare two vectors or data.frames for total equality.  WARNING: no selecting or filtering applied.  stop_condition all.equal is not TRUE.
data2data = compares two generic data.frames and checks for common UNIQUE values in columns between data.frames. stop_condition if nrow(setdiff(distinct(X), disctinct(Y))) > 0.
hier2data = compares a data frome on the right against a gold-standard heirarchy on the left. stop_condition = length(setdiff(X$location_id, Y$location_id)) > 0
hier2hier = compares two hierarchies for exact equivalence across c("location_id", "location_name", "path_to_top_parent", "most_detailed"). stop_condition is any differences.
compare_cols = compares data.frames for same column names. stop_condition is any differences.}

\item{colsX}{Only for '___2data' methods. Vector of column names in "reference" vector or data.frame - keep column order consistent!}

\item{colsY}{Only for '___2data' methods. Vector of column names in the "comparison" vector or data.frame - WARNING: MAKE SURE column order matches that of colsX}

\item{filter_statement}{# Only for '___2data' methods. All your desired filtering arguments, as a single, quoted, character string.
e.g. "location_id > 100 & most_detailed==0"
Use column names from colsX, because filtering occurs after column selection.
It's less cumbersome to filter before using preflight_checks, but this option
exists in case.}

\item{STOP}{Do you want to stop your script if there is a mismatch, or allow to continue with a WARNING message?}

\item{verbose}{Do you want verbose console output, or invisible() return of the output_list for assignment to a variable?}
}
\value{
Output_list
}
\description{
Returns a list of diagnostic information.  I recommend saving this output to
an object with a name that is diagnostically helpful if you set STOP=FALSE.
'X' is intended as the left-side, 'reference' data - that which is your gold
standard to compare against 'Y' is intended as the rigth-side 'comparison'
data - that which you want to validate AGAINST X This function may STOP a
script if specified. Many 'methods' of comparison are available - check
function arguments. Suppose your pipeline depends on having data for all
locations in a given hierarchy. Suppose you need to compare two hierarchies
directly for equality across a range of columns (c("location_id",
"location_name", "path_to_top_parent", "most_detailed") are defaults). This
functions takes a left (X) and right (Y) vector or data.frame as input, then
compares them according to a desired comparison method. If you need to
compare data.frame columns with the same content but different column names,
enter those names in the same order in colsX and colsY arguments, and the
function will use colsX (left-hand data.frame) to rename all columnn, and
output will return those names. Filtering occurs AFTER column selection.
Format all filters according to colsX names. Order of operations: select(),
setNames(), filter()
}
\examples{

library(dplyr)
source("/ihme/cc_resources/libraries/current/r/get_location_metadata.R")

MREs -----------------
source("/ihme/cc_resources/libraries/current/r/get_location_metadata.R")

# HIERARCHIES

# covid
hier_covid_771 <- get_location_metadata(111, 771, release_id = 9)
hier_covid_1020 <- get_location_metadata(111, 1020, release_id = 9)
hier_covid_mi <- fread('/mnt/share/covid-19/model-inputs/2022_03_30.01/locations/modeling_hierarchy.csv')

# Real data --------------------

# full_data
full_data <- fread('/mnt/share/covid-19/model-inputs/2022_03_30.01/full_data_unscaled.csv')
full_data_prev <- fread('/mnt/share/covid-19/model-inputs/2022_03_29.01/full_data_unscaled.csv')
full_formatted <- fread('/mnt/share/covid-19/model-inputs/2022_03_30.01/full_data_unscaled_formatted_dates.csv')

# methods ---------

## all_equal ---------------

# simple, naive check for equality
preflight_checks(X = hier_covid_1020, Y = hier_covid_1020, method = "all_equal") # pass (OK)
preflight_checks(hier_covid_1020, hier_covid_mi) # error - not equivalent (desired behavior)
# equivalent
preflight_checks(hier_covid_1020, hier_covid_1020) # pass (O)
# check LSVIDs against each other, using current as 'left side'
preflight_checks(hier_covid_1020, hier_covid_771) # fail (OK)
preflight_checks(hier_covid_1020, hier_covid_771, verbose = T) # prints warning, continues
preflight_checks(hier_covid_1020, hier_covid_771, STOP = T, verbose = T) # stops, saves errors to .GlobalEnv
preflight_checks(hier_covid_1020, hier_covid_1020, STOP = T, verbose = T) # keep going, see receipt of passing

## hier2hier -------------------
# save your output for inspection if not verbose
output_pass <- preflight_checks(hier_covid_1020, hier_covid_1020, "hier2hier")
output_pass$names_in_X_not_in_Y
output_fail <- preflight_checks(hier_covid_1020, hier_covid_771, "hier2hier")
output_fail$names_in_X_not_in_Y

## data2data -----------------
preflight_checks(full_data, full_data, "data2data")
preflight_checks(full_data, full_formatted, "data2data") # why does this pass? (OK)
preflight_checks(full_data, full_formatted, "data2data", colsX = c("location_id", "Date_formatted")) # pass (OK)
# is full_data equivalent to formatted date data?
preflight_checks(full_data, full_formatted, "data2data", colsX = names(full_data)) # pass (ok)
# compare to yesterday's data?
preflight_checks(full_data, full_data_prev, "data2data", colsX = names(full_data)) # fail (ok)

## compare_cols -----------------
preflight_checks(hier_covid_1020, hier_covid_771, "compare_cols")
preflight_checks(full_data, full_formatted, "compare_cols")


# Shapefiles ---------------------------
# No built-in method yet, but it won't be hard, and ther
shp_main <- rgdal::readOGR("/ihme/covid-19/shapefiles/covid_simp_2.shp")
shp_locs <- data.frame(location_id = shp_main$loc_id) # \%>\% mutate(location_id = as.integer(location_id)) # better, but unnecessary
class(shp_locs$location_id)
preflight_checks(hier_covid_1020, shp_locs, "hier2data") # remember, defaults to 'location_id' only

}
