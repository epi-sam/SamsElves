% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preflight_checks.R
\name{preflight_checks}
\alias{preflight_checks}
\title{Compare hierarchies or data sets against a reference}
\usage{
preflight_checks(
  X,
  Y,
  method = c("all_equal"),
  STOP = FALSE,
  verbose = FALSE,
  colsX = c("location_id"),
  colsY = NULL,
  filter_statement = NULL
)
}
\arguments{
\item{X}{Left-hand input vector or data.frame (gold standard to compare
against)}

\item{Y}{Right-hand input vector or data.frame (compared AGAINST your gold
standard, by 'method')}

\item{method}{method of comparison to be made:
\itemize{
 \item{\code{"all_equal"} : compare two vectors or \code{data.frames} for total equality.  WARNING: no selecting or filtering applied.  Stop_condition \code{all.equal} is not TRUE.}
 \item{\code{"data2data"} : compare two generic \code{data.frames} and checks for common UNIQUE values in columns between data.frames. Stop_condition if \code{nrow(setdiff(distinct(X), distinct(Y))) > 0}.}
 \item{\code{"hier2data"} : compare a data from on the right against a gold-standard heirarchy on the left. Stop_condition = \code{length(setdiff(X$location_id, Y$location_id)) > 0}}
 \item{\code{"hier2hier"} : compare two hierarchies for exact equivalence across \code{c("location_id", "location_name", "path_to_top_parent", "most_detailed")}. Stop_condition is any differences.}
 \item{\code{"compare_cols"} : compares \code{data.frames} for all same column names. stop_condition is any differences.}
}}

\item{STOP}{Do you want to STOP your script if there is a mismatch, or allow
to continue with a WARNING message?}

\item{verbose}{Do you want verbose console output, or invisible() return of
the output_list for assignment to a variable?}

\item{colsX}{Only for '___2data' methods. Vector of column names in
"reference" vector or data.frame - keep column order consistent!}

\item{colsY}{Only for '___2data' methods. Vector of column names in the
"comparison" vector or data.frame - WARNING: MAKE SURE column order matches
that of \code{colsX}}

\item{filter_statement}{Only for '___2data' methods. All your desired
  filtering arguments, as a single, quoted, character string. e.g.
  \code{"location_id > 100 & most_detailed==0"}.
\itemize{
 \item{Use column names from \code{colsX}, because filtering occurs after
 column selection. Use column names from \code{colsX}, because filtering
 occurs after column selection. It's less cumbersome to filter before using
 \code{preflight_checks}, but this option exists in case.}
}}
}
\value{
Output_list of diagnostics that may be assigned, or printed to console (\code{verbose = TRUE})
}
\description{
Returns a \code{list()} of diagnostic information, quietly or verbose, and
STOPS or continues based on user preference.  I recommend saving this output
to an object with a name that is diagnostically helpful if you set \code{STOP
or verbose = FALSE.} \code{'X'} is intended as the left-side, 'reference'
data - that which is your gold standard to compare against, and \code{'Y'} is
intended as the right-side 'comparison' data - that which you want to
validate AGAINST \code{X}.
}
\details{
This function may STOP a script if specified. Many 'methods' of comparison
are available - check function arguments. Suppose your pipeline depends on
having data for all locations in a given hierarchy. Suppose you need to
compare two hierarchies directly for equality. If you need to compare
data.frame columns with the same content but different column names, enter
those names in the same order in \code{colsX} and \code{colsY} arguments, and
the function will use \code{colsX} (left-hand data.frame) to rename all
columns, and output will return those names. Filtering occurs AFTER column
selection. Format all filters according to \code{colsX} names. Order of
operations: \code{select()}, \code{setNames()}, then \code{filter()}.
}
\examples{

library(dplyr)
source("/ihme/cc_resources/libraries/current/r/get_location_metadata.R")

MREs -----------------
source("/ihme/cc_resources/libraries/current/r/get_location_metadata.R")

# HIERARCHIES

# covid
hier_covid_771 <- get_location_metadata(111, 771, release_id = 9)
hier_covid_1020 <- get_location_metadata(111, 1020, release_id = 9)
hier_covid_mi <- fread('/mnt/share/covid-19/model-inputs/2022_03_30.01/locations/modeling_hierarchy.csv')

# Real data --------------------

# full_data
full_data <- fread('/mnt/share/covid-19/model-inputs/2022_03_30.01/full_data_unscaled.csv')
full_data_prev <- fread('/mnt/share/covid-19/model-inputs/2022_03_29.01/full_data_unscaled.csv')
full_formatted <- fread('/mnt/share/covid-19/model-inputs/2022_03_30.01/full_data_unscaled_formatted_dates.csv')

# methods ---------

## all_equal ---------------

# simple, naive check for equality
preflight_checks(X = hier_covid_1020, Y = hier_covid_1020, method = "all_equal") # pass (OK)
preflight_checks(hier_covid_1020, hier_covid_mi) # error - not equivalent (desired behavior)
# equivalent
preflight_checks(hier_covid_1020, hier_covid_1020) # pass (O)
# check LSVIDs against each other, using current as 'left side'
preflight_checks(hier_covid_1020, hier_covid_771) # fail (OK)
preflight_checks(hier_covid_1020, hier_covid_771, verbose = T) # prints warning, continues
preflight_checks(hier_covid_1020, hier_covid_771, STOP = T, verbose = T) # stops, saves errors to .GlobalEnv
preflight_checks(hier_covid_1020, hier_covid_1020, STOP = T, verbose = T) # keep going, see receipt of passing

## hier2hier -------------------
# save your output for inspection if not verbose
output_pass <- preflight_checks(hier_covid_1020, hier_covid_1020, "hier2hier")
output_pass$names_in_X_not_in_Y
output_fail <- preflight_checks(hier_covid_1020, hier_covid_771, "hier2hier")
output_fail$names_in_X_not_in_Y

## data2data -----------------
preflight_checks(full_data, full_data, "data2data")
preflight_checks(full_data, full_formatted, "data2data") # why does this pass? (OK)
preflight_checks(full_data, full_formatted, "data2data", colsX = c("location_id", "Date_formatted")) # pass (OK)
# is full_data equivalent to formatted date data?
preflight_checks(full_data, full_formatted, "data2data", colsX = names(full_data)) # pass (ok)
# compare to yesterday's data?
preflight_checks(full_data, full_data_prev, "data2data", colsX = names(full_data)) # fail (ok)

## compare_cols -----------------
preflight_checks(hier_covid_1020, hier_covid_771, "compare_cols")
preflight_checks(full_data, full_formatted, "compare_cols")


# Shapefiles ---------------------------
# No built-in method yet, coming soon, and you can compare with a little prep work.
shp_main <- rgdal::readOGR("/ihme/covid-19/shapefiles/covid_simp_2.shp")
shp_locs <- data.frame(location_id = shp_main$loc_id) # \%>\% mutate(location_id = as.integer(location_id)) # better, but unnecessary
class(shp_locs$location_id)
preflight_checks(hier_covid_1020, shp_locs, "hier2data") # remember, defaults to 'location_id' only

}
