% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_from_children_to_parents.R
\name{aggregate_from_children_to_parents}
\alias{aggregate_from_children_to_parents}
\title{Aggregate from children to parents using a hierarchy}
\usage{
aggregate_from_children_to_parents(
  DT,
  varnames_to_aggregate,
  varnames_to_aggregate_by,
  hierarchy,
  hierarchy_id = "location_id",
  drop_ids_not_in_hierarchy = TRUE,
  require_all_children = TRUE,
  start_level = max(hierarchy$level),
  stop_level = 3L,
  varname_weights = NULL,
  aggregate_proportions = FALSE,
  add_regional_scalars = FALSE,
  release_id = NULL,
  location_set_id = 35,
  require_square = TRUE,
  require_rows = TRUE,
  require_all_most_detailed = TRUE,
  verbose = TRUE,
  v_verbose = FALSE,
  tolerance_all_equal = NULL,
  aa_hard_stop = FALSE
)
}
\arguments{
\item{DT}{[data.table] e.g. some data table with hierarchy_id as a column}

\item{varnames_to_aggregate}{[chr] e.g. c("mean", "upper", "lower")}

\item{varnames_to_aggregate_by}{[chr] e.g c("year_id", "age_group_id")}

\item{hierarchy}{[data.table: default "location_id"] e.g. a location
hierarchy with required columns: `hierarchy_id`, path_to_top_parent, level,
most_detailed}

\item{hierarchy_id}{[chr] What variable does your hierarchy define, e.g.
"location_id" (2024-11-21 only supported option)}

\item{drop_ids_not_in_hierarchy}{[lgl: default TRUE] If TRUE, remove any
hierarchy_id in DT that are not in the hierarchy (e.g. location_id not in
location hierarchy)}

\item{require_all_children}{[lgl: default TRUE] If TRUE, stop if any parent
is missing children in DT}

\item{start_level}{[int: default max(hierarchy$level)] What level to start
aggregating}

\item{stop_level}{[int: default 3] Stops aggregation when the child level ==
stop_level (e.g. 3L aggregate up to national for locations, but no further;
regional scalars mean regions are larger than combined countries under them
from e.g. small islands)}

\item{varname_weights}{[chr: default NULL] - if you want to weight the
aggregation by a variable, e.g. population.  If NULL, do a simple
children-to-parent sum the values in varnames_to_aggregate within each
combination of varnames_to_aggregate_by.  If not NULL, calculate weights
for all children of each parent before aggregation.  Weights sum to 1
between all children, within each combination of varnames_to_aggregate_by.}

\item{aggregate_proportions}{[lgl: default FALSE] If TRUE, only apply
regional scalars to varname_weights}

\item{add_regional_scalars}{[lgl: default FALSE] If TRUE, will add regional
scalars (e.g. GBD Regions) to the hierarchy, and aggregate them
automatically.  This assumes your hierarchy is a location hierarchy with
location_id, path_to_top_parent, level, most_detailed columns.}

\item{release_id}{[int: default NULL] required only if add_regional_scalars =
TRUE}

\item{location_set_id}{[int: default 35] required only if
add_regional_scalars = TRUE}

\item{require_square}{[lgl: default TRUE] If TRUE, will check inputs and
outputs for square (i.e. all variables are present for all combinations of
hierarchy_id and varnames_to_aggregate_by).  If FALSE, will warn if not
square.}

\item{require_rows}{[lgl: default TRUE] If TRUE, assert_square checks data
has > 0 rows}

\item{require_all_most_detailed}{[lgl: default TRUE] If TRUE, require that
all most_detailed locations in the hierarchy are present in DT}

\item{verbose}{[lgl: default TRUE] message each parent and children being
aggregated?}

\item{v_verbose}{[lgl: default FALSE] message each parent that is not
all.equal() to its aggregated children (if parent already exists in the
dataset)?}

\item{tolerance_all_equal}{[dbl: default NULL] If NULL, use all.equal's
default tolerance for all.equal mean relative differnce check between
parent and aggregated children (if parent is already in DT).  A value of 1
means the aggregated children are double the value of the parent (you
probably did something wrong).  Use large values for large allowance in
differnces due to rounding, etc.  Adjust the tolerance to your operation's
mathematical limitations.}

\item{aa_hard_stop}{[lgl: default FALSE] If TRUE, stop if a parent is not
`all.equal()` to its aggregated children, within user-specified level of
tolerance.}
}
\value{
[data.table] aggregated data.table
}
\description{
Aggregate iteratively from leaf nodes up through an (assumed MECE) hierarchy
to the top level. Retain all child and parent values, e.g. for a location
hierarchy, retain all location_ids, and aggregate values up to the top
specified parent level.  This function is designed to be used iteratively,
starting at the leaf nodes and working up to the top level.  It will
aggregate all children of a parent, then aggregate those parents up to the
next level, and so on. Aggregation will stop at each level if aggregates are
not square.  If a parent location already exists in the data, this will check
for all.equal() between the parent and the aggregated children, and message
if v_verbose = TRUE, and throw an error if aa_hard_stop = TRUE.
}
\details{
Relies on the `children_of_parents()` function to find children of a parent
hierarchy_id e.g. location_id, then aggregates the selected columns for all
children of one parent.
}
